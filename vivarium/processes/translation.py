'''
======================
Stochastic Translation
======================
'''

import copy
import numpy as np
import random
from arrow import StochasticSystem

from vivarium.compartment.process import Process
from vivarium.data.amino_acids import amino_acids
from vivarium.utils.datum import Datum
from vivarium.utils.polymerize import Elongation, Polymerase, Template, build_stoichiometry, all_products, generate_template
from vivarium.utils.dict_utils import deep_merge

class Ribosome(Polymerase):
    pass

class Transcript(Template):
    pass

def shuffle(l):
    l = [item for item in l]
    np.random.shuffle(l)
    return l

def random_string(alphabet, length):
    string = ''
    for step in range(length):
        string += random.choice(alphabet)
    return string

#: Whether to print the parameters when initializing
#: :py:class:`Translation`
VERBOSE = True
#: Variable name for unbound ribosomes
UNBOUND_RIBOSOME_KEY = 'Ribosome'

monomer_symbols = []
monomer_ids = []

for symbol, id in amino_acids.items():
    monomer_symbols.append(symbol)
    monomer_ids.append(id)

default_translation_parameters = {
    'sequences': {
        'oA': random_string(monomer_symbols, 20),
        'oAZ': random_string(monomer_symbols, 50),
        'oB': random_string(monomer_symbols, 30),
        'oBY': random_string(monomer_symbols, 70)},
    'templates': {
        'oA': generate_template('oA', 20, ['eA']),
        'oAZ': generate_template('oAZ', 50, ['eA', 'eZ']),
        'oB': generate_template('oB', 30, ['eB']),
        'oBY': generate_template('oBY', 70, ['eB', 'eY'])},
    'transcript_affinities': {
        'oA': 1.0,
        'oAZ': 1.0,
        'oB': 1.0,
        'oBY': 1.0},
    'elongation_rate': 5.0,
    'polymerase_occlusion': 10,
    'symbol_to_monomer': amino_acids,
    'monomer_ids': monomer_ids,
    'concentration_keys': []}

class Translation(Process):
    def __init__(self, initial_parameters={}):
        '''A stochastic translation model

        .. WARNING::
            Vivarium's knowledge base uses the gene name to name the
            protein. This means that for a gene acrA that codes for
            protein ArcA, you must refer to the gene, transcript, and
            protein each as acrA.

        .. DANGER::
            This documentation will need to be updated to reflect the
            changes in `#185
            <https://github.com/CovertLab/vivarium/pull/185>`_

        :term:`Ports`:

        * **ribosomes**: Expects the ``ribosomes`` variable, whose
          value is a list of the configurations of the ribosomes
          currently active.
        * **molecules**: Expects variables for each of the RNA
          nucleotides.
        * **transcripts**: Expects variables for each transcript to
          translate. Translation will read transcripts from this port.
        * **proteins**: Expects variables for each protein product. The
          produced proteins will be added to this port as counts.
        * **concentrations**: Expects variables for each key in
          ``concentration_keys``. This will be used by a :term:`deriver`
          to convert counts to concentrations.

        Arguments:
            initial_parameters: A dictionary of configuration options.
                Accepts the following keys:

                * **sequences** (:py:class:`dict`): Maps from operon
                  name to the RNA sequence of the operon, as a
                  :py:class:`str`.
                * **templates** (:py:class:`dict`): Maps from the name
                  of an transcript to a :term:`template specification`.
                  The template specification may be generated by
                  :py:func:`vivarium.utils.polymerize.generate_template`
                  like so:

                  >>> from vivarium.utils.polymerize import (
                  ...     generate_template)
                  >>> from vivarium.utils.pretty import format_dict
                  >>> terminator_index = 5
                  >>> template = generate_template(
                  ...     'oA', terminator_index, ['product1'])
                  >>> print(format_dict(template))
                  {
                      "direction": 1,
                      "id": "oA",
                      "position": 0,
                      "sites": [],
                      "terminators": [
                          {
                              "position": 5,
                              "products": [
                                  "product1"
                              ],
                              "strength": 1.0
                          }
                      ]
                  }


                * **transcript_affinities** (:py:class:`dict`): A map
                  from the name of a transcript to the binding affinity
                  (a :py:class:`float`) of the ribosome for the
                  transcript.
                * **elongation_rate** (:py:class:`float`): The
                  elongation rate of the ribosome.

                  .. todo:: Units of elongation rate

                * **polymerase_occlusion** (:py:class:`int`): The number
                  of base pairs behind the polymerase where another
                  polymerase is occluded and so cannot bind.
                * **symbol_to_monomer** (:py:class:`dict`): Maps from
                  the symbols used to represent monomers in the RNA
                  sequence to the name of the free monomer. This should
                  generally be
                  :py:data:`vivarium.data.amino_acids.amino_acids`.
                * **monomer_ids** (:py:class:`list`): A list of the
                  names of the free monomers consumed by translation.
                  This can generally be computed as:

                  >>> import pprint
                  >>>
                  >>> from vivarium.data.amino_acids import amino_acids
                  >>> monomer_ids = amino_acids.values()
                  >>> pp = pprint.PrettyPrinter()
                  >>> pp.pprint(list(monomer_ids))
                  ['Alanine',
                   'Arginine',
                   'Asparagine',
                   'Aspartate',
                   'Cysteine',
                   'Glutamate',
                   'Glutamine',
                   'Glycine',
                   'Histidine',
                   'Isoleucine',
                   'Leucine',
                   'Lysine',
                   'Methionine',
                   'Phenylalanine',
                   'Proline',
                   'Serine',
                   'Threonine',
                   'Tryptophan',
                   'Tyrosine',
                   'Valine']

                  Note that we only included the `list()` transformation
                  to make the output prettier. The `dict_values` object
                  returned by `.values()` is sufficiently list-like for
                  use here. Also note that :py:mod:`pprint` just makes
                  the output prettier.
                * **concentration_keys** (:py:class:`list`): A list of
                  variables you want to be able to access as
                  concentrations from the *concentrations* port. The
                  actual conversion is handled by a deriver.

        Example configuring the process (uses
        :py:func:vivarium.utils.pretty.format_dict):

        >>> from vivarium.utils.pretty import format_dict
        >>> from vivarium.data.amino_acids import amino_acids
        >>> from vivarium.utils.polymerize import generate_template
        >>> configurations = {
        ...     'sequences': {
        ...         'oA': 'AWDPT',
        ...         'oAZ': 'YVEGELENGGMFISC',
        ...     },
        ...     'templates': {
        ...         'oA': generate_template('oA', 5, ['eA']),
        ...         'oAZ': generate_template('oAZ', 15, ['eA', 'eZ']),
        ...     },
        ...     'transcript_affinities': {
        ...         'oA': 1.0,
        ...         'oAZ': 1.0,
        ...     },
        ...     'elongation_rate': 10.0,
        ...     'polymerase_occlusion': 10,
        ...     'symbol_to_monomer': amino_acids,
        ...     'monomer_ids': amino_acids.values(),
        ...     'concentration_keys': []
        ... }
        >>> # We omit output using "..." below
        >>> translation = Translation(configurations)  # doctest:+ELLIPSIS
        translation parameters: ...
        >>> states = {
        ...     'ribosomes': {'ribosomes': []},
        ...     'molecules': {},
        ...     'proteins': {UNBOUND_RIBOSOME_KEY: 2},
        ...     'transcripts': {
        ...         'oA': 10,
        ...         'oAZ': 10,
        ...     }
        ... }
        >>> states['molecules'].update(
        ...     {
        ...         molecule_id: 100
        ...         for molecule_id in translation.monomer_ids
        ...     }
        ... )
        >>> update = translation.next_update(1, states)
        >>> print(format_dict(update))
        {
            "molecules": {
                "Alanine": 0,
                "Arginine": 0,
                "Asparagine": -2,
                "Aspartate": 0,
                "Cysteine": 0,
                "Glutamate": -6,
                "Glutamine": 0,
                "Glycine": -4,
                "Histidine": 0,
                "Isoleucine": 0,
                "Leucine": -2,
                "Lysine": 0,
                "Methionine": 0,
                "Phenylalanine": 0,
                "Proline": 0,
                "Serine": 0,
                "Threonine": 0,
                "Tryptophan": 0,
                "Tyrosine": -2,
                "Valine": -2
            },
            "proteins": {
                "Ribosome": -2,
                "eA": 0,
                "eZ": 0
            },
            "ribosomes": {
                "ribosomes": [
                    {
                        "id": 1,
                        "position": 9,
                        "state": "occluding",
                        "template": "oAZ",
                        "template_index": 0,
                        "terminator": 0
                    },
                    {
                        "id": 2,
                        "position": 9,
                        "state": "occluding",
                        "template": "oAZ",
                        "template_index": 0,
                        "terminator": 0
                    }
                ]
            }
        }



        '''
        self.monomer_symbols = list(amino_acids.keys())
        self.monomer_ids = list(amino_acids.values())

        self.default_parameters = default_translation_parameters

        templates = initial_parameters.get(
            'templates',
            self.default_parameters['templates'])

        self.default_parameters['protein_ids'] = all_products({
            key: Template(config)
            for key, config in templates.items()})

        self.default_parameters['transcript_order'] = list(
            initial_parameters.get(
                'transcript_affinities',
                self.default_parameters['transcript_affinities']).keys())
        self.default_parameters['molecule_ids'] = self.monomer_ids

        self.parameters = copy.deepcopy(self.default_parameters)
        self.parameters.update(initial_parameters)

        self.sequences = self.parameters['sequences']
        self.templates = self.parameters['templates']

        self.transcript_affinities = self.parameters['transcript_affinities']
        self.transcript_order = self.parameters['transcript_order']
        self.transcript_count = len(self.transcript_order)

        self.monomer_ids = self.parameters['monomer_ids']
        self.molecule_ids = self.parameters['molecule_ids']
        self.protein_ids = self.parameters['protein_ids']
        self.symbol_to_monomer = self.parameters['symbol_to_monomer']
        self.elongation = 0
        self.elongation_rate = self.parameters['elongation_rate']
        self.polymerase_occlusion = self.parameters['polymerase_occlusion']
        self.concentration_keys = self.parameters['concentration_keys']

        self.affinity_vector = np.array([
            self.transcript_affinities[transcript_key]
            for transcript_key in self.transcript_order], dtype=np.float64)

        self.stoichiometry = build_stoichiometry(self.transcript_count)

        self.initiation = StochasticSystem(self.stoichiometry)

        self.ribosome_id = 0

        concentration_keys = self.concentration_keys + self.protein_ids
        self.ports = {
            'ribosomes': ['ribosomes'],
            'molecules': self.molecule_ids,
            'transcripts': self.transcript_order,
            'proteins': concentration_keys + [UNBOUND_RIBOSOME_KEY],
            'concentrations': concentration_keys}

        if VERBOSE:
            print('translation parameters: {}'.format(self.parameters))

        super(Translation, self).__init__(self.ports, self.parameters)

    def default_settings(self):
        default_state = {
            'ribosomes': {
                'ribosomes': []},
            'molecules': {},
            'transcripts': {
                transcript_id: 1
                for transcript_id in self.transcript_order},
            'proteins': dict({
                UNBOUND_RIBOSOME_KEY: 10})}

        default_state['proteins'].update({
            protein_id: 0
            for protein_id in self.protein_ids})

        default_state['molecules'].update({
            monomer_id: 200
            for monomer_id in self.monomer_ids})

        default_state = deep_merge(
            default_state,
            self.parameters.get('initial_state', {}))

        operons = list(default_state['transcripts'].keys())
        default_emitter_keys = {
            'ribosomes': ['ribosomes'],
            'molecules': self.monomer_ids,
            'transcripts': operons,
            'proteins': self.protein_ids + [UNBOUND_RIBOSOME_KEY]}

        deriver_setting = [{
            'type': 'counts_to_mmol',
            'source_port': 'proteins',
            'derived_port': 'concentrations',
            'keys': self.protein_ids + self.concentration_keys}]

        # schema
        schema = {
            'ribosomes': {
                'ribosomes': {'updater': 'set'}}}

        return {
            'state': default_state,
            'emitter_keys': default_emitter_keys,
            'schema': schema,
            'deriver_setting': deriver_setting,
            'parameters': self.parameters}

    def next_update(self, timestep, states):
        ribosomes = list(map(Ribosome, states['ribosomes']['ribosomes']))
        proteins = states['proteins']
        molecules = states['molecules']
        transcripts = states['transcripts']
        transcript_counts = np.array([
            transcripts.get(transcript_key, 0)
            for transcript_key in self.transcript_order], dtype=np.int64)

        # Find out how many transcripts are currently blocked by a
        # newly initiated ribosome
        bound_transcripts = np.zeros(self.transcript_count, dtype=np.int64)
        ribosomes_by_transcript = {
            transcript_key: []
            for transcript_key in self.transcript_order}
        for ribosome in ribosomes:
            ribosomes_by_transcript[ribosome.template].append(ribosome)
        for index, transcript in enumerate(self.transcript_order):
            bound_transcripts[index] = len([
                ribosome
                for ribosome in ribosomes_by_transcript[transcript]
                if ribosome.is_bound()])

        # Make the state for a gillespie simulation out of total number of each
        # transcript not blocked by a bound ribosome, concatenated with the number
        # of each transcript that is bound by a ribosome.
        # These are the two states for each transcript the simulation
        # will operate on, essentially going back and forth between
        # bound and unbound states.

        original_unbound_ribosomes = proteins[UNBOUND_RIBOSOME_KEY]
        monomer_limits = {
            monomer: molecules[monomer]
            for monomer in self.monomer_ids}
        unbound_ribosomes = original_unbound_ribosomes

        templates = {
            key: Template(template)
            for key, template in self.templates.items()}

        time = 0
        now = 0
        elongation = Elongation(
            self.sequences,
            templates,
            monomer_limits,
            self.symbol_to_monomer,
            self.elongation)

        while time < timestep:
            # build the state vector for the gillespie simulation
            substrate = np.concatenate([
                transcript_counts - bound_transcripts,
                bound_transcripts,
                [unbound_ribosomes]])

            # find number of monomers until next terminator
            # distance = chromosome.terminator_distance()
            distance = 1 / self.elongation_rate

            # find interval of time that elongates to the point of the next terminator
            interval = min(distance, timestep - time)

            if interval == distance:
                # perform the elongation until the next event
                terminations, monomer_limits, ribosomes = elongation.step(
                    interval,
                    monomer_limits,
                    ribosomes)
                unbound_ribosomes += terminations
            else:
                elongation.store_partial(interval)
                terminations = 0

            # run simulation for interval of time to next terminator
            result = self.initiation.evolve(
                interval,
                substrate,
                self.affinity_vector)

            # go through each event in the simulation and update the state
            ribosome_bindings = 0
            for now, event in zip(result['time'], result['events']):
                # ribosome has bound the transcript
                transcript_key = self.transcript_order[event]
                bound_transcripts[event] += 1

                self.ribosome_id += 1
                new_ribosome = Ribosome({
                    'id': self.ribosome_id,
                    'template': transcript_key,
                    'position': 0})
                new_ribosome.bind()
                new_ribosome.start_polymerizing()
                ribosomes.append(new_ribosome)

                ribosome_bindings += 1
                unbound_ribosomes -= 1

            # deal with occluding rnap
            for ribosome in ribosomes:
                if ribosome.is_unoccluding(self.polymerase_occlusion):
                    bound_transcripts[ribosome.template_index] -= 1
                    ribosome.unocclude()

            time += interval

        # track how far elongation proceeded to start from next iteration
        self.elongation = elongation.elongation - int(elongation.elongation)

        proteins = {
            UNBOUND_RIBOSOME_KEY: unbound_ribosomes - original_unbound_ribosomes}
        proteins.update(elongation.complete_polymers)

        molecules = {
            key: count * -1
            for key, count in elongation.monomers.items()}

        update = {
            'ribosomes': {
                'ribosomes': [ribosome.to_dict() for ribosome in ribosomes]},
            'molecules': molecules,
            'proteins': proteins}

        return update


def test_translation():
    parameters = {
        'transcript_affinities': {
                'oA': 1.0,
                'oAZ': 1.0,
                'oB': 1.0,
                'oBY': 1.0},
        'elongation_rate': 10.0,
        'advancement_rate': 10.0}

    parameters = {}
    translation = Translation(parameters)

    states = {
        'ribosomes': {'ribosomes': []},
        'molecules': {},
        'proteins': {UNBOUND_RIBOSOME_KEY: 10},
        'transcripts': {
            'oA': 10,
            'oAZ': 10,
            'oB': 10,
            'oBY': 10}}
    states['molecules'].update({
        molecule_id: 100
        for molecule_id in translation.monomer_ids})

    update = translation.next_update(10.0, states)

    print(update)
    print('complete!')



if __name__ == '__main__':
    test_translation()

